[1]  >, <, | 같은 건 셸 프로그램에서만 인식할 수 있는 심볼입니다. 
즉 이것들은 배시 안에서 동작할 때 표준 입력, 출력을 조작하게 도와주는 양념일 뿐이고, exec할 때 배시가 아니라 시스템 콜을 직접적으로 이용하는 자바 프로그램은 그런 심볼을 해석할 수 없습니다. 
동작 환경 본연의 문제라 자바가 아니라 c든 node.js든 다 동일할 겁니다 
아무튼 그렇기에 자바 프로그램 안에서 bash -c 옵션을 통해 배시 위에서 명령어를 실행시키게 해서 문제가 발생하는 걸 없앴습니다. 
+ 원래는 이렇게 하면 되는 걸 모르고 일일이 명령 실행시킬 때 플래그 옵션을 줄 수 있게 하드코딩을 시켰었는데 
성공까지도 했었지만 사실 그럴 필요가 없더라고요 짧은 코드가 좋은 거니까요

[2]  그렇게 하더라도 예로 들어 foo.txt (./foo.txt)를 읽는다고 하면 상대경로의 기준이 /home/pjs인지 인텔리제이의 프로젝트 루트 폴더인지 모호합니다. 그래서 작업 디렉터리를 설정해야 합니다. 예로 들어 bash를 처음 실행했을 때의 작업 디렉터리는 로그인한 사용자의 홈 디렉터리입니다 
여담인데 cd라는 명령은 bash 내에서 작업 디렉터리를 바꿔주기 위한 bash 내부 매크로입니다 
아무튼 자바 안에서 커맨드를 실행하려면 기준이 되는 작업 디렉터리가 어딘지 설정하는 과정이 필요합니다. 사실 설정을 하지 않으면 인텔리제이 프로젝트의 루트 폴더로 설정되어 있긴 합니다.
ProcessBuilder.directory()를 통해 작업 디렉터리를 설정할 수 있습니다. 
제가 만들어둔 Exec.$()의 첫번째 인자는 작업 디렉터리이고, 두번째 인자는 bash로 넘겨 실행할 명령어 텍스트입니다
$로 이상한 메서드 명명을 한 것은 셸 위에서 돌린다는 의미를 와닿기 하기 위해 그랬습니다

[3] ProcessBuilder 자체도 사실 표준입력/출력/에러을 redirect하기 위한 .redirectInput, redirectOutput 같은 메서드들이 있습니다. 그러나 제가 이용한 방식은 bash에 명령어를 위임시켜 실행하는 방식이고, bash 명령어 안의 >, <, | 따위가 그런 역할을 해주기 때문에 그건 이용하지 않습니다.

[4] 제 경우에는, ProcessBuilder에서 .inheritIO()을 통해 자바 프로그램의 표준입력/출력 설정을 물려받지 않으면 자바 프로그램의 터미널 화면으로 입출력이 되지 않더라고요. 이건 종선님 환경에선 안 그랬던거 같은데 정확한 이유를 모르겠습니다.